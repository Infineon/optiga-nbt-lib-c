<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>hsw-nbt: Global Platform T=1&#39; Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">hsw-nbt<span id="projectnumber">&#160;1.1.1</span>
   </div>
   <div id="projectbrief">OPTIGA Authenticate NBT Host Library for C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Global Platform T=1' Library</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="global-platform-t1-library"></a></p><blockquote class="doxtable">
<p>&zwj;C library for Global Platform T=1' communication </p>
</blockquote>
<p>This library implements the Global Platform T=1' protocol as a reusable layer for generic <code>Protocol</code> stacks.</p>
<p>As the protocol only works over <a href="https://en.wikipedia.org/wiki/I%C2%B2C">I2C</a> or <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">SPI</a> a concrete driver implementation of the Infineon <code>hsw-i2c</code> or <code>hsw-spi</code> and <code>hsw-timer</code> interface is required when consuming this library.</p>
<h1><a class="anchor" id="enable-i2cspi-interface"></a>
Enable I2C/SPI interface</h1>
<ul>
<li><p class="startli">If not using <code>cmake</code> to build the code, following macros need to be defined for compilation. Define the <code>IFX_T1PRIME_USE_I2C</code> and <code>IFX_T1PRIME_INTERFACE_I2C</code> macro with a <em>true</em> value (e.g. <code>1</code>) when compiling your code (this enables the build for the <code>I2C</code> variant of the T=1' protocol).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define IFX_T1PRIME_USE_I2C 1</span></div>
<div class="line"><span class="preprocessor">#define IFX_T1PRIME_INTERFACE_I2C 1</span></div>
</div><!-- fragment --></li>
<li>If using <code>cmake</code> to build the code. <div class="fragment"><div class="line">// Set IFX_T1PRIME_USE_I2C from CmakeLists.txt file.</div>
<div class="line">set(IFX_T1PRIME_USE_I2C ON)</div>
</div><!-- fragment --> or, during <code>cmake</code> build, we can use <div class="fragment"><div class="line">cmake -DIFX_T1PRIME_USE_I2C=0N ..</div>
</div><!-- fragment --></li>
</ul>
<blockquote class="doxtable">
<p>&zwj;Note: The <code>SPI</code> interface is enabled by setting <code>IFX_T1PRIME_USE_I2C=OFF</code>, which will not define <code>IFX_T1PRIME_INTERFACE_I2C</code>. By default <code>IFX_T1PRIME_USE_I2C=ON</code> is enabled from CmakeLists.txt file. </p>
</blockquote>
<h1><a class="anchor" id="platform-specific-interface-implementations"></a>
Platform specific interface implementations</h1>
<ul>
<li><p class="startli"><code>hsw-i2c</code> or <code>hsw-spi</code>:</p>
<p class="startli"><code>hsw-i2c</code> or <code>hsw-spi</code> interface is used to abstract the I2C/SPI-specific communication functionality from the target platform. This interface is built on the <code>hsw-protocol</code> APIs. To implement concrete implementation of I2C/SPI driver, (at least) the following functions need to be provided. These functions shall mainly wrap the target MCU's I2C/SPI functions that can be used in hsw-protocol library.</p><ul>
<li>A function to initialize the <code>ifx_protocol_t</code> object with the concrete implementation (e.g. <code>ifx_i2c_psoc6_initialize()</code>).This function sets up all members of the provided <code>ifx_protocol_t</code> struct and makes it usable in a generic protocol stack. This function shall do the platform-specific I2C/SPI driver initialization.</li>
<li>A function to transmit data from the host MCU to the secure element via <code>I2C/SPI</code> (e.g. <code>ifx_i2c_psoc6_transmit()</code>).</li>
<li>A function to receive data from secure element to host MCU via <code>I2C/SPI</code> (e.g. <code>ifx_i2c_psoc6_receive()</code>)</li>
</ul>
<p class="startli">For the I2C/SPI-specific functionality the getters and setters also need to be implemented. These shall be used to update the I2C/SPI driver's parameters.(e.g. for I2C - frequency, slave address, or guard time). These getters and setters are defined in the <code><a class="el" href="ifx-i2c_8h.html" title="Generic API for I2C drivers.">infineon/ifx-i2c.h</a></code> or <code>infineon/ifx-spi.h</code> interface, which has to be included in the platform-specific implementation.</p>
<p class="startli">For the SPI specific functionality the following getters and setters need to be implemented:</p><ul>
<li><code>ifx_spi_get_clock_frequency(ifx_protocol_t *self, uint32_t *frequency_hz_buffer)</code></li>
<li><code>ifx_spi_set_clock_frequency(ifx_protocol_t *self, uint32_t frequency_hz)</code></li>
<li><code>ifx_spi_get_clock_polarity(ifx_protocol_t *self, bool *cpol_buffer)</code></li>
<li><code>ifx_spi_set_clock_polarity(ifx_protocol_t *self, bool cpol)</code></li>
<li><code>ifx_spi_get_clock_phase(ifx_protocol_t *self, bool *cpha_buffer)</code></li>
<li><code>ifx_spi_set_clock_phase(ifx_protocol_t *self, bool cpha)</code></li>
<li><code>ifx_spi_get_buffer_size(ifx_protocol_t *self, size_t *buffer_size_buffer)</code></li>
<li><code>ifx_spi_set_buffer_size(ifx_protocol_t *self, size_t buffer_size)</code></li>
<li><code>ifx_spi_get_guard_time(ifx_protocol_t *self, uint32_t *guard_time_us_buffer)</code></li>
<li><code>ifx_spi_set_guard_time(ifx_protocol_t *self, uint32_t guard_time_us)</code></li>
</ul>
<p class="startli">For the I2C specific functionality the following getters and setters need to be implemented:</p><ul>
<li><code>ifx_i2c_get_clock_frequency(ifx_protocol_t *self, uint32_t *frequency_buffer)</code></li>
<li><code>ifx_i2c_set_clock_frequency(ifx_protocol_t *self, uint32_t frequency)</code></li>
<li><code>ifx_i2c_get_slave_address(ifx_protocol_t *self, uint16_t *address_buffer)</code></li>
<li><code>ifx_i2c_set_slave_address(ifx_protocol_t *self, uint16_t address)</code></li>
<li><code>ifx_i2c_get_guard_time(ifx_protocol_t *self, uint32_t *guard_time_us_buffer)</code></li>
<li><code>ifx_i2c_set_guard_time(ifx_protocol_t *self, uint32_t guard_time_us)</code></li>
</ul>
</li>
<li><p class="startli"><code>hsw-timer</code>:</p>
<p class="startli">The <code>hsw-timer</code> interface is used to abstract timer calls from the target platform. Objects of the <code><a class="el" href="structifx__timer__t.html" title="Generic struct for joinable timers.">ifx_timer_t</a></code> struct are used throughout all libraries to measure timeout values, waiting times, etc. For a concrete implementation of the timer interface, (at least) the following function(s) need to be provided. These functions shall mainly wrap the target MCU's timer functions which are defined in the hsw-timer interface.</p><ul>
<li>A function to initialize the <code><a class="el" href="structifx__timer__t.html" title="Generic struct for joinable timers.">ifx_timer_t</a></code> object with the concrete implementation (e.g. <code>ifx_timer_psoc6_initialize()</code>). This function sets up all members of the provided <code><a class="el" href="structifx__timer__t.html" title="Generic struct for joinable timers.">ifx_timer_t</a></code> struct. This function shall do the platform-specific timer driver initialization.</li>
<li><code>void *_start</code>: Pointer to start of the timer.</li>
<li><code>uint64_t _duration</code>: Duration of the timer.</li>
</ul>
<p class="startli">For the timer-specific functionality, the following functions need to be implemented. These functions are defined in the <code><a class="el" href="ifx-timer_8h.html" title="Generic C API for joinable timers.">infineon/ifx-timer.h</a></code> interface, which has to be included in the platform-specific implementation.</p><ul>
<li><code>ifx_timer_set(ifx_timer_t *timer, uint64_t us)</code>: Sets a new timer for the amount of microseconds provided in <code>us</code> and stores all required information in its <code>timer</code> parameter.</li>
<li><code>ifx_timer_has_elapsed(const ifx_timer_t *timer)</code>: Checks if the given <code>timer</code> has elapsed. Developers can use the members set by <code>ifx_timer_set()</code> to check if the timer has already elapsed.</li>
<li><code>ifx_timer_join(const ifx_timer_t *timer)</code>: Waits for the given <code>timer</code> to elapse. Once again developers can use the data they previously set in <code>ifx_timer_set()</code> to calculate timer end times, etc.</li>
<li><code>ifx_timer_destroy(ifx_timer_t *timer)</code>: If <code>ifx_timer_set()</code> allocated any dynamic data this function can be used to perform the necessary cleanup.</li>
</ul>
</li>
<li><p class="startli"><code>hsw-logger</code>:</p>
<p class="startli"><code>hsw-logger</code> interface offers generic <code>ifx_logger_t</code> structs that can be populated by concrete implementations. These <code>ifx_logger_t</code> structs are self-contained and can therefore be nested, joined, etc. The actual logging function uses <code>printf</code> syntax so it should feel familiar to <code>C</code> developers. These loggers can be configured at runtime to a specific level to only trace the desired data (Debug, Info, Warning, Error). Concrete platform implementations are required to use the host MCU's preferred logging methods (e.g. stdout, file-logger). To provide concrete implementation of logger interface, (at least) the following function(s)need to be provided. These functions shall mainly wrap the target MCU's logging function which are used in the hsw-logger interface.</p><ul>
<li>A function to initialize the <code>ifx_logger_t</code> object with the concrete implementation (e.g. <code>ifx_logger_psoc6_initialize()</code>). This function sets up all members of the provided <code>ifx_logger_t</code> struct. This function shall do the platform-specific logger initialization.</li>
<li><code>ifx_logger_log_callback_t _log</code>: Logging function for concrete implementation. This _log function shall be set to platform-specific implementation of the logging function, (e.g. printf, UART writing, etc., ).</li>
<li><code>ifx_logger_set_level_callback_t _set_level</code>: Set log level. By default <code>ifx_logger_set_level()</code> will simply update <code>ifx_logger_t._level</code>. If no custom setter is required use <code>NULL</code>.</li>
<li><code>ifx_logger_destroy_callback_t _destructor</code>: <code>ifx_logger_destroy()</code> will call <code>free()</code> for ifx_logger_t._data . If any further cleanup is necessary implement it in this function. Otherwise use <code>NULL</code>.</li>
<li><code>ifx_log_level _level</code>: Set by <code>ifx_logger_set_level()</code>. This shall be initialized to 0.</li>
<li><code>void *_data</code>: Logger properties/state that can be used internally. This shall be set to <code>NULL</code>, if there is no logger properties to be used.</li>
</ul>
<p class="startli">The actual logging functions are available in the <code><a class="el" href="ifx-logger_8h.html" title="Generic logging API.">infineon/ifx-logger.h</a></code> interface.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ifx-logger_8h.html">infineon/ifx-logger.h</a>&quot;</span></div>
<div class="ttc" id="aifx-logger_8h_html"><div class="ttname"><a href="ifx-logger_8h.html">ifx-logger.h</a></div><div class="ttdoc">Generic logging API.</div></div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="usage-3"></a>
Usage</h1>
<p>Initialize the t1-prime protocol and call the protocol APIs for further protocol communications.</p>
<div class="fragment"><div class="line"><span class="comment">/* Polling Mode */</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ifx-t1prime_8h.html">infineon/ifx-t1prime.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ifx-protocol_8h.html">infineon/ifx-protocol.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Provide Protocol instance of SPI/I2C driver</span></div>
<div class="line">ifx_protocol_t driver;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Initialize protocol driver layer here with I2C/SPI implementation.</span></div>
<div class="line"><span class="comment">Note: Does not work without initialized driver layer for I2C/SPI. */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// code placeholder</span></div>
<div class="line"> </div>
<div class="line">ifx_protocol_t protocol;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prerequisite: I2C/SPI and Timer concrete implementation to be integrated.</span></div>
<div class="line">ifx_t1prime_initialize(&amp;protocol, &amp;driver);</div>
<div class="line"> </div>
<div class="line">uint8_t data[] = {0x00u, 0xa4u, 0x04u, 0x00u};</div>
<div class="line">uint8_t *response = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span> response_len = 0u;</div>
<div class="line">ifx_protocol_activate(&amp;protocol, &amp;response, &amp;response_len);</div>
<div class="line">ifx_protocol_transceive(&amp;protocol, data, <span class="keyword">sizeof</span>(data), &amp;response, &amp;response_len);</div>
<div class="line">ifx_protocol_destroy(&amp;protocol);</div>
<div class="ttc" id="aifx-protocol_8h_html"><div class="ttname"><a href="ifx-protocol_8h.html">ifx-protocol.h</a></div><div class="ttdoc">Generic protocol API (ISO/OSI stack).</div></div>
<div class="ttc" id="aifx-t1prime_8h_html"><div class="ttname"><a href="ifx-t1prime_8h.html">ifx-t1prime.h</a></div><div class="ttdoc">Global Platform T=1' protocol.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="irq--polling-mode"></a>
IRQ / Polling mode</h2>
<p>The implementation supports both the T=1' interrupt as well as the polling mode to detect when the secure element is ready to send data. By default polling mode is used.</p>
<p>To enable interrupt mode use <code>ifx_t1prime_set_irq_handler()</code> to set a custom interrupt handler. This interrupt handler shall wait until the GPIO interrupt has triggered or the given amount of microseconds has elapsed. It is up to the concrete implementation to check which GPIO pin to use and how to check if the time has elapsed. This enables platform independent code with interrupt handling being an optional plug-in solution.</p>
<div class="fragment"><div class="line"><span class="comment">/* IRQ Mode */</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ifx-error_8h.html">infineon/ifx-error.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ifx-protocol_8h.html">infineon/ifx-protocol.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ifx-t1prime_8h.html">infineon/ifx-t1prime.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="ifx-error_8h.html#ac1e04ea3cb51d67fb865a51ed1d13634">ifx_status_t</a> irq(ifx_protocol_t *self, uint32_t timeout)</div>
<div class="line">{</div>
<div class="line">  uint32_t end_time = now() + timeout;</div>
<div class="line">  <span class="keywordflow">while</span> (now() &lt; end_time)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (gpio_read() == GPIO_HIGH)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code hl_define" href="ifx-t1prime_8h.html#a8d7aadaab90cba5d3ab625aeea7f2053">IFX_T1PRIME_IRQ_TRIGGERED</a>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_define" href="ifx-error_8h.html#ac65cceb50ebd5dfde1f6433bda70cd83">IFX_ERROR</a>(<a class="code hl_define" href="ifx-t1prime-lib_8h.html#a1e31db2220e72b737c0594b2a6016696">LIB_T1PRIME</a>, <a class="code hl_define" href="ifx-t1prime_8h.html#a1ec7f1a2b10293c2d8de600d46289393">IFX_T1PRIME_IRQ</a>, <a class="code hl_define" href="ifx-t1prime_8h.html#a92434f752ed2969eed6577d7c2b7623a">IFX_T1PRIME_IRQ_NOT_TRIGGERED</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Provide Protocol instance of SPI/I2C driver</span></div>
<div class="line">ifx_protocol_t driver;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Initialize protocol driver layer here with I2C/SPI implementation.</span></div>
<div class="line"><span class="comment">Note: Does not work without initialized driver layer for I2C/SPI. */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// code placeholder</span></div>
<div class="line"> </div>
<div class="line">ifx_protocol_t protocol;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prerequisite: I2C/SPI and Timer concrete implementation to be integrated.</span></div>
<div class="line">ifx_t1prime_initialize(&amp;protocol, &amp;driver);</div>
<div class="line">ifx_t1prime_set_irq_handler(&amp;protocol, &amp;irq);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The rest can be reused as any other protocol stack</span></div>
<div class="line">uint8_t data[] = {0x00u, 0xa4u, 0x04u, 0x00u};</div>
<div class="line">uint8_t *response = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span> response_len = 0u;</div>
<div class="line">ifx_protocol_activate(&amp;protocol, &amp;response, &amp;response_len);</div>
<div class="line">ifx_protocol_transceive(&amp;protocol, data, <span class="keyword">sizeof</span>(data), &amp;response, &amp;response_len);</div>
<div class="line">ifx_protocol_destroy(&amp;protocol);</div>
<div class="ttc" id="aifx-error_8h_html"><div class="ttname"><a href="ifx-error_8h.html">ifx-error.h</a></div><div class="ttdoc">Infineon specific error code creation and parsing.</div></div>
<div class="ttc" id="aifx-error_8h_html_ac1e04ea3cb51d67fb865a51ed1d13634"><div class="ttname"><a href="ifx-error_8h.html#ac1e04ea3cb51d67fb865a51ed1d13634">ifx_status_t</a></div><div class="ttdeci">uint32_t ifx_status_t</div><div class="ttdoc">Custom return code type used by all Infineon host software libraries.</div><div class="ttdef"><b>Definition</b> <a href="ifx-error_8h_source.html#l00092">ifx-error.h:92</a></div></div>
<div class="ttc" id="aifx-error_8h_html_ac65cceb50ebd5dfde1f6433bda70cd83"><div class="ttname"><a href="ifx-error_8h.html#ac65cceb50ebd5dfde1f6433bda70cd83">IFX_ERROR</a></div><div class="ttdeci">#define IFX_ERROR(module, function, reason)</div><div class="ttdoc">Creates IFX encoded error code for given module, function and reason.</div><div class="ttdef"><b>Definition</b> <a href="ifx-error_8h_source.html#l00084">ifx-error.h:84</a></div></div>
<div class="ttc" id="aifx-t1prime-lib_8h_html_a1e31db2220e72b737c0594b2a6016696"><div class="ttname"><a href="ifx-t1prime-lib_8h.html#a1e31db2220e72b737c0594b2a6016696">LIB_T1PRIME</a></div><div class="ttdeci">#define LIB_T1PRIME</div><div class="ttdoc">T1prime library identifier ID.</div><div class="ttdef"><b>Definition</b> <a href="ifx-t1prime-lib_8h_source.html#l00019">ifx-t1prime-lib.h:19</a></div></div>
<div class="ttc" id="aifx-t1prime_8h_html_a1ec7f1a2b10293c2d8de600d46289393"><div class="ttname"><a href="ifx-t1prime_8h.html#a1ec7f1a2b10293c2d8de600d46289393">IFX_T1PRIME_IRQ</a></div><div class="ttdeci">#define IFX_T1PRIME_IRQ</div><div class="ttdoc">IFX error encoding function identifier for ifx_t1prime_irq_handler_t.</div><div class="ttdef"><b>Definition</b> <a href="ifx-t1prime_8h_source.html#l00088">ifx-t1prime.h:88</a></div></div>
<div class="ttc" id="aifx-t1prime_8h_html_a8d7aadaab90cba5d3ab625aeea7f2053"><div class="ttname"><a href="ifx-t1prime_8h.html#a8d7aadaab90cba5d3ab625aeea7f2053">IFX_T1PRIME_IRQ_TRIGGERED</a></div><div class="ttdeci">#define IFX_T1PRIME_IRQ_TRIGGERED</div><div class="ttdoc">Return code for successful calls to ifx_t1prime_irq_handler_t.</div><div class="ttdef"><b>Definition</b> <a href="ifx-t1prime_8h_source.html#l00082">ifx-t1prime.h:82</a></div></div>
<div class="ttc" id="aifx-t1prime_8h_html_a92434f752ed2969eed6577d7c2b7623a"><div class="ttname"><a href="ifx-t1prime_8h.html#a92434f752ed2969eed6577d7c2b7623a">IFX_T1PRIME_IRQ_NOT_TRIGGERED</a></div><div class="ttdeci">#define IFX_T1PRIME_IRQ_NOT_TRIGGERED</div><div class="ttdoc">Error reason if interrupt did not trigger in time during ifx_t1prime_irq_handler_t.</div><div class="ttdef"><b>Definition</b> <a href="ifx-t1prime_8h_source.html#l00094">ifx-t1prime.h:94</a></div></div>
</div><!-- fragment --> <h2><a class="anchor" id="gp-t1-por"></a>
GP T=1' POR</h2>
<p>The GP T=1' host library implements the proprietary Power On Reset(POR) with S-block(POR-Request) with PCB 1101 1000b (0xd8). This POR performs cold reset and does not replay a response. The Host Device shall wait for a duration of Power Wake-Up Time (PWT) according to the GP T=1' specification before initiating any communication with the Secure Element. Calling <a class="el" href="ifx-t1prime_8h.html#ad7dcf36b360a8fef8b96b5b1fd174367" title="Performs Global Platform T=1&#39; power on reset (POR).">ifx_t1prime_s_por()</a> will automatically wait for PWT after transmitting the S(POR) block. The function shall be called as shown below.</p>
<div class="fragment"><div class="line"><span class="comment">/* POR usage */</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ifx-protocol_8h.html">infineon/ifx-protocol.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ifx-t1prime_8h.html">infineon/ifx-t1prime.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize protocol stack</span></div>
<div class="line">ifx_protocol_t driver;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Initialize protocol driver layer here with I2C/SPI implementation.</span></div>
<div class="line"><span class="comment">Note: Does not work without initialized driver layer for I2C/SPI. */</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Code placeholder</span></div>
<div class="line"> </div>
<div class="line">ifx_protocol_t protocol;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prerequisite: I2C/SPI and Timer concrete implementation to be integrated.</span></div>
<div class="line">ifx_t1prime_initialize(&amp;protocol, &amp;driver);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The rest can be reused as any other protocol stack</span></div>
<div class="line">ifx_protocol_activate(&amp;protocol, &amp;response, &amp;response_len);</div>
<div class="line"><a class="code hl_function" href="ifx-t1prime_8h.html#ad7dcf36b360a8fef8b96b5b1fd174367">ifx_t1prime_s_por</a>(&amp;protocol);</div>
<div class="line">ifx_protocol_destroy(&amp;protocol);</div>
<div class="ttc" id="aifx-t1prime_8h_html_ad7dcf36b360a8fef8b96b5b1fd174367"><div class="ttname"><a href="ifx-t1prime_8h.html#ad7dcf36b360a8fef8b96b5b1fd174367">ifx_t1prime_s_por</a></div><div class="ttdeci">ifx_status_t ifx_t1prime_s_por(ifx_protocol_t *self)</div><div class="ttdoc">Performs Global Platform T=1' power on reset (POR).</div></div>
</div><!-- fragment --><h1><a class="anchor" id="components-3"></a>
Components</h1>
<ul>
<li><b>t1-prime</b> This component includes setting physical layer parameters for Global Platform T=1' protocol and function pointer implementations for hsw_protocol library. This components is responsible for framing and transceiving the APDUs as per GP T=1' protocol. The pre-requisite is that, this protocol library requires concrete implementation of physical layer protocol(I2C /SPI).</li>
</ul>
<h1><a class="anchor" id="directory-structure-4"></a>
Directory Structure</h1>
<p>The library directory is structured according to the Pitchfork Layout.</p>
<div class="fragment"><div class="line">hsw-t1prime</div>
<div class="line">|-- .cmake/                 # Includes sources for dependency management</div>
<div class="line">|-- LICENSES/               # Includes list of licenses used for the library</div>
<div class="line">|-- data/                   # Includes Doxygen, cppcheck configuration files</div>
<div class="line">|-- docs/                   # Includes documentation source files, images and the generated API reference</div>
<div class="line">|-- include/                # Public Headers(.h) of the library</div>
<div class="line">|-- src/                    # Sources(.c) and Private headers(.h) of the library</div>
<div class="line">|-- .clang-format           # clang-format configuration file</div>
<div class="line">|-- .gitignore              # Library specific gitignore file</div>
<div class="line">|-- CMakeLists.txt          # Cmake build configurations for the library</div>
<div class="line">`-- README.md               # Overview of the hsw-t1prime library</div>
</div><!-- fragment --><h1><a class="anchor" id="dependencies-4"></a>
Dependencies</h1>
<ul>
<li><b>hsw-crc</b> This dependent library is a generic library used for CRC calculation. This library is used for CRC calculation of GlobalPlatform T=1' protocol stack.</li>
<li><b>hsw-error</b> This dependent library is used for creating and parsing error information.</li>
<li><b>hsw-i2c</b> This interface is used for the I2C protocol implementation of the Global Platform T=1' protocol stack. It contains mock implementations of source code.</li>
<li><b>hsw-spi</b> This interface is used for the SPI protocol implementation of the Global Platform T=1' protocol stack. It contains mock implementations of source code.</li>
<li><b>hsw-logger</b> This dependent library is a generic abstraction interface used for logging information/errors. It offers generic interface that can be populated by concrete implementations, such as file logger or console logger.</li>
<li><b>hsw-protocol</b> This dependent library provides functionalities such as initialize, transceive and terminate to communicate with the device. It can be implemented for any communication protocol such as I2C, UART, etc.</li>
<li><b>hsw-timer</b> This dependent library provides the functionalities of <code>Timer</code> related APIs used in Global Platform T=1' protocol stack. It contains mock implementations of source code.</li>
</ul>
<h1><a class="anchor" id="references-4"></a>
References</h1>
<ul>
<li>Global Platform Technology APDU Transport over SPI / I2C, Version 1.0 </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
